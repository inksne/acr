from pathlib import Path
from typing import Optional

import git



class GitRepo:
    """Manages Git Repository operations."""

    def __init__(self, repo_path: Path = Path('.')) -> None:
        self.repo_path = repo_path

        try:
            self.repo = git.Repo(repo_path)

        except git.InvalidGitRepositoryError:
            raise ValueError(f"Not a valid git repository: {repo_path}")


    def get_current_branch(self) -> str:
        """Get current branch name."""
        return self.repo.active_branch.name


    def get_modified_files(self) -> list[Path]:
        """Get list of modified files in working tree."""
        modified_files = []


        for item in self.repo.index.diff(None):
            if item.a_path:
                modified_files.append(Path(item.a_path))

        for item in self.repo.index.diff('HEAD'):
            if item.a_path:
                modified_files.append(Path(item.a_path))


        return list(set(modified_files))  # Remove duplicates


    def get_staged_files(self) -> list[Path]:
        """Get files staged for commit."""
        return [Path(item.a_path) for item in self.repo.index.diff('HEAD') if item.a_path]


    def get_unstaged_files(self) -> list[Path]:
        """Get files with unstaged changes."""
        return [Path(item.a_path) for item in self.repo.index.diff(None) if item.a_path]


    def get_untracked_files(self) -> list[Path]:
        """Get untracked files."""
        return [Path(item) for item in self.repo.untracked_files]


    def get_diff_for_file(self, file_path: Path) -> str:
        """Get diff for specific file."""
        try:
            return self.repo.git.diff(file_path)

        except git.GitCommandError:
            return ""


    def get_file_content_at_commit(self, file_path: Path, commit_hash: str) -> Optional[str]:
        """Get file content at specific commit."""
        try:
            return self.repo.git.show(f"{commit_hash}:{file_path}")

        except git.GitCommandError:
            return None


    def is_dirty(self) -> bool:
        """Check if repository has uncommitted changes."""
        return self.repo.is_dirty()


    def get_remote_url(self) -> Optional[str]:
        """Get remote repository URL."""
        try:
            return self.repo.remotes.origin.url
        except AttributeError:
            return None



class GitHookManager:
    """Manages Git hooks installation."""

    def __init__(self, repo_path: Path = Path(".")) -> None:
        self.repo_path = repo_path
        self.git_dir = repo_path / ".git"
        
        if not self.git_dir.exists():
            raise ValueError(f"Not a git repository: {repo_path}")


    def install_hook(self, hook_type: str, hook_script: str) -> Path:
        """Install Git hook."""
        hooks_dir = self.git_dir / "hooks"
        hooks_dir.mkdir(exist_ok=True)
        
        hook_path = hooks_dir / hook_type
        
        # Create hook script with shebang and content
        script_content = f"""
            #!/bin/sh
            # Auto-generated by ACR - Automated Code Review
            {hook_script}
        """
        
        hook_path.write_text(script_content)
        hook_path.chmod(0o755)  # Make executable
        
        return hook_path


    def create_pre_commit_hook(self) -> Path:
        """Create pre-commit hook for automatic code review."""

        hook_script = """
            echo "ðŸ” Running ACR - Automated Code Review..."
            acr review changed --strict

            if [ $? -ne 0 ]; then
                echo "âŒ Code review failed. Please fix the issues before committing."
                exit 1
            fi

            echo "âœ… Code review passed!"
        """

        return self.install_hook("pre-commit", hook_script)


    def create_pre_push_hook(self) -> Path:
        """Create pre-push hook for branch analysis."""

        hook_script = """
            echo "ðŸ” ACR: Analyzing changes before push..."
            acr review current --output json
        """

        return self.install_hook("pre-push", hook_script)


    def hook_exists(self, hook_type: str) -> bool:
        """Check if hook already exists."""

        hook_path = self.git_dir / "hooks" / hook_type
        return hook_path.exists()